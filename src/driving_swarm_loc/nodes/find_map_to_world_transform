#!/usr/bin/env python

import math
import rospy
import tf2_ros
import numpy as np
import geometry_msgs.msg
from tf.transformations import quaternion_from_euler
from geometry_msgs.msg import Vector3, Quaternion, Transform
from pycpd import rigid_registration


def lookup_transforms(tf_from, tf_to, bot_count):
    replace_string = '##'  # use '##' as placeholder for the bot-id
    result = []
    for id in range(bot_count):  # 0,1,2,..N-1
        tf_to_inserted_id = tf_to.replace(replace_string, str(id+1))
        tf_from_inserted_id = tf_from.replace(replace_string, str(id+1))
        transformation_msg = lookup_transform_withoutExeption(
            tf_from_inserted_id, tf_to_inserted_id)
        if transformation_msg:
            result.append(transformation_msg)
    return result


def lookup_transform_withoutExeption(tf_from, tf_to):
    try:
        transform_msg = tf_buffer.lookup_transform(tf_from,
                                                   tf_to,
                                                   rospy.Time(0))
    except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException):
        print("No Translation found from '" + tf_from + "' to '" + tf_to + "'")
        return
    return transform_msg


def create_transform_msg((x,y,z),(qx,qy,qz,qw)):
    t = Transform(Vector3(x, y, z), Quaternion(qx, qy, qz, qw))
    return t


def broadcast_tf(tf_broadcaster, parent, child, transform):
    t = geometry_msgs.msg.TransformStamped()
    t.header.stamp = rospy.Time.now()
    t.header.frame_id = parent
    t.child_frame_id = child
    t.transform = transform
    tf_broadcaster.sendTransform(t)


def find_transform(transform_msg1, transform_msg2):
    coords_1 = [[msg.transform.translation.x,
                 msg.transform.translation.y] for msg in transform_msg1]
    coords_2 = [[msg.transform.translation.x,
                 msg.transform.translation.y] for msg in transform_msg2]
    X = np.array(coords_1)
    Y = np.array(coords_2)

    reg = rigid_registration.RigidRegistration(**{'X': X, 'Y': Y})
    TY, (s_reg, R_reg, t_reg) = reg.register()
    return R_reg, t_reg


def update_tf(bot_count):

    transforms_world_cam_tb = lookup_transforms(
                                        "world",
                                        "loc_system_fake_camera/tb3_##",
                                        bot_count)
    transforms_map_tbN_basefootprint = lookup_transforms(
                                        "map",
                                        "tb3_##/base_footprint",
                                        bot_count)

    if transforms_world_cam_tb and \
            transforms_map_tbN_basefootprint and \
            len(transforms_map_tbN_basefootprint) \
            == len(transforms_world_cam_tb):  # same size

        rotation, translation = find_transform(transforms_world_cam_tb,
                                               transforms_map_tbN_basefootprint)

        rotation_angle = math.acos(rotation[0][0])

        q = quaternion_from_euler(0, 0, rotation_angle)
        broadcast_tf(tf_broadcaster, 'world', "map",
                    (create_transform_msg((translation[0], translation[1], 0), q)))


if __name__ == '__main__':
    rospy.init_node("transform_correlator_AMCL2Cam")

    bot_count = rospy.get_param('~bot_count')
    # create tf buffer
    tf_buffer = tf2_ros.Buffer()
    tf2_ros.TransformListener(tf_buffer)

    # create tf broadcaster
    tf_broadcaster = tf2_ros.TransformBroadcaster()

    rate = rospy.Rate(5)  # Hz

    # main loop:
    while not rospy.is_shutdown():
        update_tf(bot_count)
        rate.sleep()
